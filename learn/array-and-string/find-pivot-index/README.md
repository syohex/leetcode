# memo

## 補足

- index == 0, index == nums.size() - 1の場合左, 右の総和はそれぞれどうなるかという話があるが, 特に問題文には記述されていない. テストケースにはその場合総和は 0となっているので, indexが端の場合も考慮する必要がある

## 手順

- ベクタの長さが 1以下の場合は -1を返す
- 累積和ベクタを作成する
- numsをループ
  - 左の総和は index == 0の場合 0, それ以外の場合は累積和ベクタの index - 1の値
  - 右の総和は index == nums.size() - 1の場合 0, それ以外の場合は累積和ベクタの indexの値
  - 左右の総和が等しくなるときその indexを返す
- 関数末尾に到達した場合一致したものが見つからないということなので -1を返す


## オーダ

- 累積和を使うことで計算量は 2Nであり, O(N)となる.
